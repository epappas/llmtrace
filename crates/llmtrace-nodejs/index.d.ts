/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** A security finding returned to JavaScript. */
export interface Finding {
  /** Severity level: "Info", "Low", "Medium", "High", or "Critical". */
  severity: string
  /** Category: "prompt_injection", "pii_detected", "encoding_attack", etc. */
  findingType: string
  /** Human-readable description. */
  description: string
  /** Confidence score (0.0–1.0). */
  confidence: number
  /** Where in the input the issue was found. */
  location?: string
}
/** An agent action to report for security analysis. */
export interface AgentActionInput {
  /**
   * Action type: "tool_call", "skill_invocation", "command_execution",
   * "web_access", or "file_access".
   */
  actionType: string
  /** Name of the tool, command, URL, or file path. */
  name: string
  /** Arguments or parameters (optional). */
  arguments?: string
  /** Result or output (optional, truncated to 4 KB internally). */
  result?: string
  /** Duration in milliseconds (optional). */
  durationMs?: number
  /** Whether the action succeeded (defaults to true). */
  success?: boolean
  /** Exit code for command executions (optional). */
  exitCode?: number
  /** HTTP method for web access (optional). */
  httpMethod?: string
  /** HTTP status code for web access (optional). */
  httpStatus?: number
  /** File operation: "read", "write", or "delete" (optional). */
  fileOperation?: string
}
/** Information about a recorded trace span. */
export interface SpanInfo {
  /** Unique span ID. */
  spanId: string
  /** Trace ID this span belongs to. */
  traceId: string
  /** Operation name. */
  operationName: string
  /** LLM provider. */
  provider: string
  /** Model name. */
  modelName: string
  /** Duration in milliseconds (if complete). */
  durationMs?: number
  /** Security score (0–100, if analysed). */
  securityScore?: number
  /** Number of security findings. */
  findingsCount: number
  /** Estimated cost in USD (if available). */
  estimatedCostUsd?: number
}
/** Options for creating a new tracer. */
export interface TracerOptions {
  /** Tenant identifier (used for all spans created by this tracer). */
  tenantId?: string
}
/** Options for starting a new span. */
export interface StartSpanOptions {
  /** Operation name (e.g., "chat_completion", "embedding"). */
  operationName: string
  /** LLM provider name (e.g., "OpenAI", "Anthropic"). */
  provider: string
  /** Model name (e.g., "gpt-4o", "claude-3-5-sonnet"). */
  modelName: string
  /** The input prompt or messages. */
  prompt: string
  /** Optional parent span ID. */
  parentSpanId?: string
}
/** Options for finishing a span. */
export interface FinishSpanOptions {
  /** The LLM response text. */
  response?: string
  /** Error message if the request failed. */
  error?: string
  /** HTTP status code. */
  statusCode?: number
  /** Number of prompt tokens. */
  promptTokens?: number
  /** Number of completion tokens. */
  completionTokens?: number
  /** Time to first token in milliseconds. */
  timeToFirstTokenMs?: number
}
/** Summary of all traced spans. */
export interface TracerSummary {
  /** Total number of spans (active + finished). */
  totalSpans: number
  /** Number of active (unfinished) spans. */
  activeSpans: number
  /** Number of finished spans. */
  finishedSpans: number
  /** Total security findings across all spans. */
  totalFindings: number
  /** Total estimated cost in USD. */
  totalCostUsd: number
  /** Highest security score across all spans. */
  maxSecurityScore?: number
}
/**
 * Quick-check a prompt for security issues.
 *
 * Creates a temporary analyzer for one-shot use.
 * Returns an array of findings.
 */
export declare function checkPrompt(prompt: string): Array<Finding>
/** Quick-check a response for security issues. */
export declare function checkResponse(response: string): Array<Finding>
/**
 * Quick estimate cost for a model request.
 *
 * Returns the cost in USD, or `null` if the model is unknown.
 */
export declare function estimateCost(model: string, promptTokens: number, completionTokens: number): number | null
/**
 * Instrument a simulated LLM call: analyze prompt, response, estimate cost.
 *
 * Returns an object with findings and cost. This is a convenience function
 * for simple use cases that don't need full span tracking.
 */
export interface InstrumentResult {
  /** Security findings from prompt and response analysis. */
  findings: Array<Finding>
  /** Estimated cost in USD (null if model is unknown). */
  estimatedCostUsd?: number
  /** Highest severity found (null if no findings). */
  maxSeverity?: string
  /** Overall security score (0–100, null if no findings). */
  securityScore?: number
}
/**
 * Instrument an LLM call by analyzing the prompt and response for security
 * issues and estimating cost.
 */
export declare function instrument(prompt: string, response: string, model: string, promptTokens?: number | undefined | null, completionTokens?: number | undefined | null): InstrumentResult
/**
 * Security analyzer for LLM prompts and responses.
 *
 * Wraps the regex-based `RegexSecurityAnalyzer` from `llmtrace-security`.
 * All analysis is synchronous and CPU-only.
 */
export declare class SecurityAnalyzer {
  /** Create a new security analyzer with all built-in detection patterns. */
  constructor()
  /** Analyze a prompt for injection attacks and PII. */
  analyzePrompt(prompt: string): Array<Finding>
  /** Analyze a response for PII leakage and data exfiltration. */
  analyzeResponse(response: string): Array<Finding>
  /** Analyze both prompt and response, returning combined findings. */
  analyzeInteraction(prompt: string, response: string): Array<Finding>
  /**
   * Analyze a list of agent actions for suspicious patterns.
   *
   * Checks for dangerous commands, suspicious URLs, and sensitive file access.
   */
  analyzeAgentActions(actions: Array<AgentActionInput>): Array<Finding>
  /** Get the analyzer name. */
  get name(): string
  /** Get the analyzer version. */
  get version(): string
  /** Get the list of finding types this analyzer can detect. */
  supportedFindingTypes(): Array<string>
}
/**
 * Cost estimator for LLM API requests.
 *
 * Ships with built-in pricing for common commercial models (OpenAI, Anthropic).
 * Custom pricing can be added via `addCustomModel`.
 */
export declare class CostEstimator {
  /** Create a new cost estimator with built-in pricing. */
  constructor()
  /**
   * Estimate cost in USD for a request.
   *
   * Returns the estimated cost, or `null` if the model is not recognised.
   */
  estimate(model: string, promptTokens: number, completionTokens: number): number | null
  /** Add custom pricing for a model (per 1 million tokens). */
  addCustomModel(model: string, inputPerMillion: number, outputPerMillion: number): void
  /** List all known model names (built-in + custom). */
  knownModels(): Array<string>
}
/**
 * LLM Security Tracer for instrumenting LLM calls.
 *
 * Provides methods to create trace spans, record completions, attach
 * security findings, and report agent actions.
 *
 * ```js
 * const tracer = new LlmSecTracer({ tenantId: "my-tenant" });
 * const span = tracer.startSpan({
 *   operationName: "chat_completion",
 *   provider: "OpenAI",
 *   modelName: "gpt-4o",
 *   prompt: "Hello, world!"
 * });
 * // ... make LLM call ...
 * tracer.finishSpan(span.spanId, { response: "Hi there!" });
 * const summary = tracer.getSummary();
 * ```
 */
export declare class LlmSecTracer {
  /** Create a new LLM security tracer. */
  constructor(options?: TracerOptions | undefined | null)
  /** Start a new trace span. Returns span info including the generated span ID. */
  startSpan(options: StartSpanOptions): SpanInfo
  /** Finish a span with a response or error. */
  finishSpan(spanId: string, options: FinishSpanOptions): SpanInfo
  /** Report agent actions for a span (analysed for security). */
  reportActions(spanId: string, actions: Array<AgentActionInput>): Array<Finding>
  /** Get a summary of all traced spans. */
  getSummary(): TracerSummary
  /** Get the tenant ID for this tracer. */
  get tenantId(): string
  /** Export all finished spans as JSON. */
  exportSpans(): string
  /** Get all findings across all spans (active + finished). */
  getAllFindings(): Array<Finding>
}
